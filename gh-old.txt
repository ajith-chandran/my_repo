import requests
import time
import json
import os
import argparse
import random
import string
import sys
import threading
from jinja2 import Template
from datetime import datetime
from colorama import Fore, Style, init as colorama_init
from urllib.parse import urlparse
import shelve

colorama_init(autoreset=True)

class APIRunner:
    def __init__(self, sequence_name, environment, verbosity, resume_code=None):
        base_dir = os.path.dirname(os.path.abspath(__file__))
        config_path = os.path.join(base_dir, 'config.json')
        with open(config_path, 'r') as f:
            self.config = json.load(f)

        self.sequence_name = sequence_name
        self.environment = environment
        self.variables = self.config.get('env', {}).copy()
        self.generators = self.config.get('generators', {})
        self.base_dir = base_dir
        self.skip_retry_flag = False
        self.verbosity = verbosity
        self.resume_code = resume_code
        self.session_status = {}

        if resume_code:
            with shelve.open(os.path.join(base_dir, 'session_db')) as db:
                session = db.get(resume_code)
                if not session:
                    raise Exception(f"Session code {resume_code} not found.")
                self.sequence_name = session['sequence']
                self.environment = session['environment']
                self.variables.update(session['variables'])
                self.resume_from_step = session['failed_step']
        else:
            self.resume_from_step = None

    def listen_for_skip(self):
        print("Press 's' then Enter at any time to skip retries for the current step.")
        while True:
            if sys.stdin.read(1).lower() == 's':
                self.skip_retry_flag = True
                break

    def render_template(self, template_str):
        template = Template(template_str)
        return template.render(**self.variables)

    def extract_variables(self, extract_config, response_json):
        for var_name, rule in extract_config.items():
            if isinstance(rule, str):
                value = self.get_nested_value(response_json, rule)
            elif isinstance(rule, dict) and 'from' in rule and 'match' in rule and 'select' in rule:
                array_data = self.get_nested_value(response_json, rule['from'])
                value = None
                if isinstance(array_data, list):
                    for item in array_data:
                        match_field, match_value = list(rule['match'].items())[0]
                        if item.get(match_field) == match_value:
                            value = item.get(rule['select'])
                            break
                else:
                    value = None
            else:
                value = None

            if value is not None:
                self.variables[var_name] = value
            else:
                print(f"Warning: Could not extract {var_name} using rule {rule}")

    def load_template(self, template_path):
        full_path = os.path.join(self.base_dir, template_path)
        with open(full_path, 'r') as f:
            return f.read()

    def evaluate_success_condition(self, condition, response_json):
        failed_messages = []

        def evaluate(single_condition):
            if 'env_var' in single_condition:
                value = self.variables.get(single_condition['env_var'])
            else:
                value = self.get_nested_value(response_json, single_condition['path'])

            result = False
            if 'equals' in single_condition:
                expected = self.render_template(single_condition['equals'])
                result = str(value).lower() == expected.lower()
            elif 'exists' in single_condition:
                result = single_condition['exists'] == (value is not None)
            elif 'not_exists' in single_condition:
                result = single_condition['not_exists'] == (value is None)

            if not result and 'message' in single_condition:
                rendered_msg = self.render_template(single_condition['message'])
                failed_messages.append(rendered_msg)
            return result

        if isinstance(condition, dict) and 'conditions' in condition:
            logic = condition.get('logic', 'AND').upper()
            conditions = condition['conditions']
            results = [evaluate(c) for c in conditions]
            if not (all(results) if logic == 'AND' else any(results)):
                for msg in failed_messages:
                    print(f"[Condition Failed] {msg}")
                return False
            return True
        elif isinstance(condition, list):
            results = [evaluate(c) for c in condition]
            if not all(results):
                for msg in failed_messages:
                    print(f"[Condition Failed] {msg}")
                return False
            return True
        else:
            return evaluate(condition)

    def interruptible_sleep(self, duration, final_attempt=False):
        if final_attempt:
            return
        waited = 0
        interval = 0.2
        while waited < duration:
            if self.skip_retry_flag:
                break
            time.sleep(interval)
            waited += interval

    def make_request(self, step_name):
        step = self.config['api_calls'][step_name]
        retries = step.get('retries')
        retry_delay = step.get('retry_delay', 2)
        duration_limit = step.get('duration_limit', 300)
        timeout = step.get('timeout', 10)
        start_time = datetime.now()
        attempt = 0
        max_attempts = retries or (duration_limit // retry_delay)
        proceed_on_failure = step.get('proceed_on_failure', False)

        self.skip_retry_flag = False
        threading.Thread(target=self.listen_for_skip, daemon=True).start()

        while True:
            final_attempt = (retries is not None and attempt == retries - 1) or \
                            (retries is None and (datetime.now() - start_time).total_seconds() + retry_delay > duration_limit)
            attempt += 1
            try:
                # (Truncated actual request logic for brevity)
                # Simulate API request and success condition...
                success = False  # Replace with real logic
                if success:
                    self.session_status[step_name] = 'Success'
                    return
                else:
                    raise Exception("Condition Not Met")
            except Exception as e:
                reason = "User Interrupted" if self.skip_retry_flag else str(e)
                self.session_status[step_name] = reason
                if self.skip_retry_flag or final_attempt:
                    if not proceed_on_failure:
                        self.save_session(step_name)
                        raise
                    return
                self.interruptible_sleep(retry_delay, final_attempt=final_attempt)

    def save_session(self, failed_step):
        session_code = ''.join(random.choices(string.digits, k=5))
        with shelve.open(os.path.join(self.base_dir, 'session_db')) as db:
            db[session_code] = {
                'sequence': self.sequence_name,
                'environment': self.environment,
                'variables': self.variables,
                'failed_step': failed_step,
                'timestamp': str(datetime.now())
            }
        print(f"Session saved. Resume with: --resume {session_code}")

    def run(self):
        sequence = self.config['sequences'][self.sequence_name]
        start_index = 0
        if self.resume_from_step:
            try:
                start_index = sequence.index(self.resume_from_step)
            except ValueError:
                print(f"Resume step {self.resume_from_step} not found in sequence. Starting from beginning.")
        for step in sequence[start_index:]:
            try:
                self.make_request(step)
            except Exception as e:
                print(f"Step {step} failed: {e}")
                if not self.config['api_calls'][step].get("proceed_on_failure", False):
                    print("Halting execution due to failure.")
                    break

        self.print_summary()

    def print_summary(self):
        print("\n--- Step Summary ---")
        for step, status in self.session_status.items():
            color = Fore.GREEN if status == 'Success' else Fore.RED
            print(f"{step}: {color}{status}{Style.RESET_ALL}")

if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument('--run', nargs=2, metavar=('SEQUENCE', 'ENV'))
    parser.add_argument('--resume', metavar='CODE')
    args = parser.parse_args()

    if args.run:
        sequence, env = args.run
        runner = APIRunner(sequence, env, verbosity=0)
    elif args.resume:
        runner = APIRunner(None, None, verbosity=0, resume_code=args.resume)
    else:
        print("Usage: --run <SEQUENCE> <ENV> or --resume <CODE>")
        sys.exit(1)

    runner.run()